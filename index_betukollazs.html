<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Betűkollázs Szerkesztő PRO</title>
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            background: #eef2f5; 
            margin: 0; 
            overflow: hidden; 
        }
        
        /* Desktop layout */
        @media (min-width: 769px) {
            .container-main { 
                display: flex; 
                width: 100%; 
                height: 100vh; 
            }
            #preview-area { 
                flex: 1; 
                background: #dcdde1; 
                display: flex; 
                justify-content: center; 
                align-items: center; 
                padding: 30px; 
                overflow: auto; 
            }
            #settings-area { 
                width: 400px; 
                background: white; 
                border-left: 1px solid #ccc; 
                display: flex; 
                flex-direction: column; 
                height: 100vh; 
                box-shadow: -5px 0 15px rgba(0,0,0,0.05); 
            }
        }
        
        /* Mobile layout */
        @media (max-width: 768px) {
            .container-main { 
                display: flex; 
                flex-direction: column; 
                width: 100%; 
                height: 100vh; 
            }
            #preview-area { 
                height: 60vh;
                background: #dcdde1; 
                display: flex; 
                justify-content: center; 
                align-items: center; 
                padding: 15px; 
                overflow: auto;
                flex-shrink: 0;
            }
            #settings-area { 
                height: 40vh;
                background: white; 
                border-top: 2px solid #ccc; 
                display: flex; 
                flex-direction: column; 
                overflow: hidden;
            }
        }
        
        canvas { 
            box-shadow: 0 15px 40px rgba(0,0,0,0.2); 
            background: white; 
            max-width: 95%; 
            max-height: 95%; 
            cursor: pointer; 
        }
        
        /* Tab Navigation */
        .tab-navigation {
            display: flex;
            background: #f8f9fa;
            border-bottom: 2px solid #dee2e6;
            flex-shrink: 0;
            overflow-x: auto;
            white-space: nowrap;
        }
        
        .tab-button {
            flex: 1;
            padding: 12px 8px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: 600;
            color: #6c757d;
            transition: all 0.2s;
            border-bottom: 3px solid transparent;
            min-width: fit-content;
        }
        
        .tab-button:hover {
            background: #e9ecef;
            color: #495057;
        }
        
        .tab-button.active {
            color: #0d6efd;
            background: white;
            border-bottom-color: #0d6efd;
        }
        
        .tab-button i {
            display: block;
            font-size: 1.2rem;
            margin-bottom: 4px;
        }
        
        @media (max-width: 768px) {
            .tab-button {
                font-size: 0.65rem;
                padding: 10px 6px;
            }
            .tab-button i {
                font-size: 1rem;
                margin-bottom: 2px;
            }
        }
        
        /* Tab Content */
        .tab-content-wrapper {
            flex: 1;
            overflow-y: auto;
            padding: 15px 20px;
        }
        
        .tab-pane {
            display: none;
        }
        
        .tab-pane.active {
            display: block;
        }
        
        /* Form Elements */
        label { 
            display: block; 
            margin-bottom: 4px; 
            font-size: 0.72rem; 
            font-weight: 700; 
            color: #555; 
            text-transform: uppercase; 
            letter-spacing: 0.5px; 
        }
        
        input[type="number"], input[type="text"], select { 
            width: 100%; 
            padding: 6px 10px; 
            margin-bottom: 10px; 
            border: 1px solid #ddd; 
            border-radius: 4px; 
            font-size: 13px; 
        }
        
        input[type="color"] { 
            width: 100%; 
            height: 35px; 
            border: none; 
            padding: 0; 
            cursor: pointer; 
            border-radius: 4px; 
        }
        
        input[type="range"] { 
            width: 100%; 
            margin-bottom: 10px; 
        }
        
        .input-row { 
            display: flex; 
            gap: 10px; 
            align-items: flex-start; 
            margin-bottom: 5px; 
        }
        
        .input-col { 
            flex: 1; 
        }
        
        .checkbox-row { 
            display: flex; 
            align-items: center; 
            margin-bottom: 8px; 
            cursor: pointer; 
            padding: 5px 0; 
        }
        
        .checkbox-row input { 
            margin-right: 8px; 
            width: auto; 
            cursor: pointer; 
        }
        
        .checkbox-row label { 
            margin: 0; 
            font-weight: normal; 
            cursor: pointer; 
            text-transform: none; 
            font-size: 0.9rem; 
            color: #333; 
        }
        
        .btn-action { 
            width: 100%; 
            padding: 12px; 
            border: none; 
            border-radius: 4px; 
            cursor: pointer; 
            font-weight: bold; 
            margin-top: 10px; 
            transition: 0.2s; 
            font-size: 1rem; 
        }
        
        .btn-success { 
            background: #27ae60; 
            color: white; 
        }
        
        .btn-success:hover { 
            background: #219150; 
        }
        
        .img-container { 
            max-height: 60vh; 
            width: 100%; 
            background-color: #f7f7f7; 
            overflow: hidden; 
            position: relative; 
        }
        
        .svg-overlay { 
            position: absolute; 
            z-index: 100; 
            pointer-events: none; 
            top: 0; 
            left: 0; 
            overflow: visible; 
        }
        
        .download-section {
            padding: 15px 20px;
            border-top: 1px solid #dee2e6;
            background: #f8f9fa;
            flex-shrink: 0;
        }
    </style>
</head>
<body>

    <div class="container-main">
        <div id="preview-area">
            <canvas id="main-canvas"></canvas>
        </div>

        <div id="settings-area">
            <!-- Tab Navigation -->
            <div class="tab-navigation">
                <button class="tab-button active" onclick="switchTab(0)">
                    <i class="fas fa-layer-group"></i>
                    <span>Szerkezet</span>
                </button>
                <button class="tab-button" onclick="switchTab(1)">
                    <i class="far fa-square"></i>
                    <span>Vászon</span>
                </button>
                <button class="tab-button" onclick="switchTab(2)">
                    <i class="fas fa-font"></i>
                    <span>Szó Stílus</span>
                </button>
                <button class="tab-button" onclick="switchTab(3)">
                    <i class="fas fa-arrow-up"></i>
                    <span>Felső</span>
                </button>
                <button class="tab-button" onclick="switchTab(4)">
                    <i class="fas fa-arrow-down"></i>
                    <span>Alsó</span>
                </button>
            </div>
            
            <!-- Tab Content -->
            <div class="tab-content-wrapper">
                <!-- Tab 1: Szerkezet & Méretek -->
                <div class="tab-pane active" id="tab-0">
                    <label>Kis Képek Mérete (cm)</label>
                    <div class="input-row">
                        <div class="input-col">
                            <label>Szélesség</label>
                            <input type="number" id="slot-width" value="10.5" step="0.1" onchange="handleSlotResize('width')">
                        </div>
                        <div class="input-col">
                            <label>Magasság</label>
                            <input type="number" id="slot-height" value="6.0" step="0.1" onchange="handleSlotResize('height')">
                        </div>
                        <div style="padding-top: 20px;" title="Képarány rögzítése">
                            <input type="checkbox" id="lock-slot-ratio" checked> <i class="fas fa-link"></i>
                        </div>
                    </div>

                    <label>Térközök (Gap) (cm)</label>
                    <div class="input-row">
                        <div class="input-col">
                            <label>Vízszintes</label>
                            <input type="number" id="gap-x" value="0" step="0.1" onchange="updateSizes('gap')">
                        </div>
                        <div class="input-col">
                            <label>Függőleges</label>
                            <input type="number" id="gap-y" value="0" step="0.1" onchange="updateSizes('gap')">
                        </div>
                    </div>

                    <label>Kollázs Igazítása (Margón belül)</label>
                    <select id="collage-align" onchange="draw()">
                        <option value="center" selected>Középen</option>
                        <option value="top">Fent</option>
                        <option value="bottom">Lent</option>
                    </select>
                </div>

                <!-- Tab 2: Vászon & Pozíció -->
                <div class="tab-pane" id="tab-1">
                    <div class="checkbox-row">
                        <input type="checkbox" id="auto-resize-canvas" checked onchange="updateSizes('toggle')">
                        <label for="auto-resize-canvas" style="display:inline; text-transform:none;">Automata / Csatolt méretezés</label>
                    </div>

                    <label>Vászon Háttérszíne</label>
                    <input type="color" id="global-bg-color" value="#ffffff" onchange="draw()">
                    
                    <label>Teljes Méret (cm)</label>
                    <div class="input-row">
                        <div class="input-col">
                            <input type="number" id="canvas-width" value="21" step="0.5" onchange="handleCanvasResize('width')">
                        </div>
                        <div class="input-col">
                            <input type="number" id="canvas-height" value="24" step="0.5" onchange="handleCanvasResize('height')">
                        </div>
                    </div>

                    <label style="margin-top:10px;">Margók (cm)</label>
                    <div class="input-row">
                        <div class="input-col"><label>Fent</label><input type="number" id="margin-top" value="0" step="0.5" onchange="updateSizes('margin')"></div>
                        <div class="input-col"><label>Lent</label><input type="number" id="margin-bottom" value="0" step="0.5" onchange="updateSizes('margin')"></div>
                    </div>
                    <div class="input-row">
                        <div class="input-col"><label>Bal</label><input type="number" id="margin-left" value="0" step="0.5" onchange="updateSizes('margin')"></div>
                        <div class="input-col"><label>Jobb</label><input type="number" id="margin-right" value="0" step="0.5" onchange="updateSizes('margin')"></div>
                    </div>
                </div>

                <!-- Tab 3: Szó Stílus -->
                <div class="tab-pane" id="tab-2">
                    <label>Szó</label>
                    <input type="text" id="input-word" value="LOVE" oninput="updateWord()">
                    
                    <label>Betűtípus</label>
                    <select id="word-font-family" onchange="draw()">
                        <option value="Arial">Arial</option>
                        <option value="Times New Roman">Times New Roman</option>
                        <option value="'Segoe UI', sans-serif">Segoe UI</option>
                        <option value="Verdana">Verdana</option>
                        <option value="Georgia">Georgia</option>
                        <option value="Impact">Impact</option>
                        <option value="'Courier New', monospace">Courier New</option>
                    </select>

                    <div class="input-row">
                        <div class="input-col">
                            <label>Szín</label>
                            <input type="color" id="word-color" value="#000000" onchange="draw()">
                        </div>
                        <div class="input-col">
                            <div class="checkbox-row"><input type="checkbox" id="word-bold" checked onchange="draw()"><label>Félkövér</label></div>
                            <div class="checkbox-row"><input type="checkbox" id="word-italic" onchange="draw()"><label>Dőlt</label></div>
                        </div>
                    </div>

                    <label>Betűméret (A képekhez képest)</label>
                    <input type="range" id="word-size-percent" min="10" max="100" value="100" oninput="draw()">
                </div>

                <!-- Tab 4: Felső Szöveg -->
                <div class="tab-pane" id="tab-3">
                    <input type="text" id="header-text" placeholder="Szöveg beírása..." oninput="updateSizes('text')">
                    <div class="input-row">
                        <div class="input-col">
                            <label>Sáv mérete (Szorzó)</label>
                            <input type="number" id="header-zone-mult" value="3.0" step="0.1" onchange="updateSizes('text')">
                            <small style="font-size: 10px; color: #666;">(Betűméret * Szorzó)</small>
                        </div>
                    </div>
                    <label>Igazítás (Vászon teteje és Kollázs között)</label>
                    <select id="header-align" onchange="draw()">
                        <option value="center" selected>Középen</option>
                        <option value="top">Fent</option>
                        <option value="bottom">Lent</option>
                    </select>

                    <div class="input-row mt-2">
                        <div class="input-col">
                            <label>Betűtípus</label>
                            <select id="header-font" onchange="draw()">
                                <option value="Arial">Arial</option>
                                <option value="Georgia">Georgia</option>
                                <option value="'Segoe UI'">Segoe UI</option>
                                <option value="Impact">Impact</option>
                            </select>
                        </div>
                        <div class="input-col">
                            <label>Szín</label>
                            <input type="color" id="header-color" value="#000000" onchange="draw()">
                        </div>
                    </div>

                    <div class="input-row">
                        <div class="input-col">
                            <label>Méret (px)</label>
                            <input type="number" id="header-size" value="60" onchange="updateSizes('text')">
                        </div>
                    </div>
                    <div class="checkbox-row">
                        <input type="checkbox" id="header-bold" checked onchange="draw()"> <label class="me-3">B</label>
                        <input type="checkbox" id="header-italic" onchange="draw()"> <label>I</label>
                    </div>
                </div>

                <!-- Tab 5: Alsó Szöveg -->
                <div class="tab-pane" id="tab-4">
                    <input type="text" id="footer-text" placeholder="Szöveg beírása..." oninput="updateSizes('text')">
                    <div class="input-row">
                        <div class="input-col">
                            <label>Sáv mérete (Szorzó)</label>
                            <input type="number" id="footer-zone-mult" value="3.0" step="0.1" onchange="updateSizes('text')">
                            <small style="font-size: 10px; color: #666;">(Betűméret * Szorzó)</small>
                        </div>
                    </div>
                    <label>Igazítás (Kollázs alja és Vászon alja között)</label>
                    <select id="footer-align" onchange="draw()">
                        <option value="center" selected>Középen</option>
                        <option value="top">Fent</option>
                        <option value="bottom">Lent</option>
                    </select>

                    <div class="input-row mt-2">
                        <div class="input-col">
                            <label>Betűtípus</label>
                            <select id="footer-font" onchange="draw()">
                                <option value="Arial">Arial</option>
                                <option value="Georgia">Georgia</option>
                                <option value="'Segoe UI'">Segoe UI</option>
                                <option value="Impact">Impact</option>
                            </select>
                        </div>
                        <div class="input-col">
                            <label>Szín</label>
                            <input type="color" id="footer-color" value="#000000" onchange="draw()">
                        </div>
                    </div>

                    <div class="input-row">
                        <div class="input-col">
                            <label>Méret (px)</label>
                            <input type="number" id="footer-size" value="60" onchange="updateSizes('text')">
                        </div>
                    </div>
                    <div class="checkbox-row">
                        <input type="checkbox" id="footer-bold" checked onchange="draw()"> <label class="me-3">B</label>
                        <input type="checkbox" id="footer-italic" onchange="draw()"> <label>I</label>
                    </div>
                </div>
            </div>
            
            <!-- Download Section -->
            <div class="download-section">
                <button class="btn-action btn-success" onclick="downloadCanvas()">
                    <i class="fas fa-download"></i> Letöltés (JPG)
                </button>
            </div>
        </div>
    </div>

    <input type="file" id="image-uploader" accept="image/*" style="display:none;">

    <div class="modal fade" id="cropperModal" tabindex="-1" data-bs-backdrop="static">
        <div class="modal-dialog modal-xl">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Kép szerkesztése</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div class="img-container">
                        <img id="cropper-image" src="" style="max-width: 100%;">
                    </div>
                </div>
                <div class="modal-footer" style="justify-content: space-between;">
                    <button type="button" class="btn btn-outline-secondary" onclick="document.getElementById('image-uploader').click()">
                        <i class="fas fa-exchange-alt"></i> Kép cseréje
                    </button>
                    <div>
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Mégsem</button>
                        <button type="button" class="btn btn-primary" id="crop-save-btn">Mentés</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const PPI = 118.11;
        
        let state = {
            word: "LOVE",
            slots: [],
            slotWidthCm: 10.5,
            slotHeightCm: 6.0,
            gaps: { x: 0, y: 0 },
            canvasWidthCm: 21.0,
            canvasHeightCm: 24.0,
            margins: { top: 0, right: 0, bottom: 0, left: 0 },
            autoResize: true,
            lockSlotRatio: true,
            activeSlotIndex: -1
        };

        let cropper = null;
        let svgOverlayElement = null;
        const cropperModal = new bootstrap.Modal(document.getElementById('cropperModal'));
        const uploader = document.getElementById('image-uploader');
        const canvas = document.getElementById('main-canvas');
        const ctx = canvas.getContext('2d');
        const measureCanvas = document.createElement('canvas');
        const measureCtx = measureCanvas.getContext('2d');

        function switchTab(index) {
            document.querySelectorAll('.tab-button').forEach((btn, i) => {
                btn.classList.toggle('active', i === index);
            });
            document.querySelectorAll('.tab-pane').forEach((pane, i) => {
                pane.classList.toggle('active', i === index);
            });
        }

        function init() {
            rebuildSlots();
            state.slotWidthCm = parseFloat(document.getElementById('slot-width').value);
            state.slotHeightCm = parseFloat(document.getElementById('slot-height').value);
            updateSizes('init');
            setupEvents();
        }

        function rebuildSlots() {
            const rows = state.word.length;
            const cols = 2;
            const newSlots = [];
            let index = 0;
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const existing = state.slots[index];
                    newSlots.push({
                        id: index,
                        row: r,
                        col: c,
                        img: existing ? existing.img : null,
                        originalUrl: existing ? existing.originalUrl : null,
                        bgColor: existing ? existing.bgColor : '#eeeeee'
                    });
                    index++;
                }
            }
            state.slots = newSlots;
        }

        function updateWord() {
            const newVal = document.getElementById('input-word').value;
            if (newVal && newVal !== state.word) {
                state.word = newVal.replace(/\s/g, '');
                rebuildSlots();
                updateSizes('word');
            }
        }

        function readInputs() {
            state.margins.top = parseFloat(document.getElementById('margin-top').value) || 0;
            state.margins.bottom = parseFloat(document.getElementById('margin-bottom').value) || 0;
            state.margins.left = parseFloat(document.getElementById('margin-left').value) || 0;
            state.margins.right = parseFloat(document.getElementById('margin-right').value) || 0;
            state.gaps.x = parseFloat(document.getElementById('gap-x').value) || 0;
            state.gaps.y = parseFloat(document.getElementById('gap-y').value) || 0;
        }

        function handleSlotResize(changedDim) {
            state.lockSlotRatio = document.getElementById('lock-slot-ratio').checked;
            let w = parseFloat(document.getElementById('slot-width').value) || 10;
            let h = parseFloat(document.getElementById('slot-height').value) || 6;

            if (state.lockSlotRatio) {
                const currentRatio = state.slotWidthCm / state.slotHeightCm;
                if (changedDim === 'width') {
                    h = w / currentRatio;
                    document.getElementById('slot-height').value = h.toFixed(2);
                } else {
                    w = h * currentRatio;
                    document.getElementById('slot-width').value = w.toFixed(2);
                }
            }
            state.slotWidthCm = w;
            state.slotHeightCm = h;
            updateSizes('slot');
        }

        function handleCanvasResize(changedDim) {
            state.autoResize = document.getElementById('auto-resize-canvas').checked;
            state.lockSlotRatio = document.getElementById('lock-slot-ratio').checked;
            
            if (!state.autoResize) {
                state.canvasWidthCm = parseFloat(document.getElementById('canvas-width').value);
                state.canvasHeightCm = parseFloat(document.getElementById('canvas-height').value);
                draw();
                return;
            }

            const newCanvasW = parseFloat(document.getElementById('canvas-width').value);
            readInputs();
            
            if (changedDim === 'width' && state.lockSlotRatio) {
                const availableForSlots = newCanvasW - state.margins.left - state.margins.right - state.gaps.x;
                
                if (availableForSlots > 0) {
                    const newSlotW = availableForSlots / 2;
                    const scaleFactor = newSlotW / state.slotWidthCm;
                    
                    state.slotWidthCm = newSlotW;
                    state.slotHeightCm = state.slotHeightCm * scaleFactor;
                    
                    document.getElementById('slot-width').value = state.slotWidthCm.toFixed(2);
                    document.getElementById('slot-height').value = state.slotHeightCm.toFixed(2);
                }
            }
            updateSizes('canvas_manual');
        }

        function updateSizes(source) {
            readInputs();
            state.autoResize = document.getElementById('auto-resize-canvas').checked;

            if (state.autoResize) {
                syncCanvasToContent();
            } else {
                state.canvasWidthCm = parseFloat(document.getElementById('canvas-width').value);
                state.canvasHeightCm = parseFloat(document.getElementById('canvas-height').value);
            }
            draw();
        }

        function syncCanvasToContent() {
            const collageW = (state.slotWidthCm * 2) + state.gaps.x;
            const rows = state.word.length;
            const collageH = (state.slotHeightCm * rows) + (state.gaps.y * (rows - 1));
            
            const headerTxt = document.getElementById('header-text').value;
            const footerTxt = document.getElementById('footer-text').value;
            const headerSizeCm = parseFloat(document.getElementById('header-size').value) / PPI;
            const footerSizeCm = parseFloat(document.getElementById('footer-size').value) / PPI;
            const headerMult = parseFloat(document.getElementById('header-zone-mult').value) || 1.5;
            const footerMult = parseFloat(document.getElementById('footer-zone-mult').value) || 1.5;

            const headerH_cm = headerTxt ? (headerSizeCm * headerMult) : 0;
            const footerH_cm = footerTxt ? (footerSizeCm * footerMult) : 0;

            const totalW = collageW + state.margins.left + state.margins.right;
            const totalH = collageH + headerH_cm + footerH_cm + state.margins.top + state.margins.bottom;

            state.canvasWidthCm = totalW;
            state.canvasHeightCm = totalH;

            document.getElementById('canvas-width').value = state.canvasWidthCm.toFixed(2);
            document.getElementById('canvas-height').value = state.canvasHeightCm.toFixed(2);
            
            canvas.width = state.canvasWidthCm * PPI;
            canvas.height = state.canvasHeightCm * PPI;
        }

        function getVisualMetrics(text, font, fontSize) {
            const size = Math.ceil(fontSize * 3.0);
            measureCanvas.width = size;
            measureCanvas.height = size;
            measureCtx.clearRect(0, 0, size, size);
            measureCtx.font = font;
            measureCtx.fillStyle = '#000';
            measureCtx.textBaseline = 'top';
            measureCtx.fillText(text, size/4, size/4);

            const imageData = measureCtx.getImageData(0, 0, size, size).data;
            let topY = size, bottomY = 0;
            let found = false;

            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    if (imageData[(y * size + x) * 4 + 3] > 0) {
                        found = true;
                        topY = Math.min(topY, y);
                        bottomY = Math.max(bottomY, y);
                    }
                }
            }

            if (!found) return { height: fontSize, top: 0, bottom: 0 };

            return {
                height: bottomY - topY + 1,
                top: topY - size/4,
                bottom: bottomY - size/4
            };
        }

        function hexToRgba(hex, alpha) {
            let r = 0, g = 0, b = 0;
            if (hex.length === 4) {
                r = parseInt(hex[1] + hex[1], 16);
                g = parseInt(hex[2] + hex[2], 16);
                b = parseInt(hex[3] + hex[3], 16);
            } else if (hex.length === 7) {
                r = parseInt(hex.substring(1, 3), 16);
                g = parseInt(hex.substring(3, 5), 16);
                b = parseInt(hex.substring(5, 7), 16);
            }
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function draw() {
            const cW = parseFloat(document.getElementById('canvas-width').value) * PPI;
            const cH = parseFloat(document.getElementById('canvas-height').value) * PPI;
            canvas.width = cW;
            canvas.height = cH;
            
            ctx.fillStyle = document.getElementById('global-bg-color').value;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const slotW = state.slotWidthCm * PPI;
            const slotH = state.slotHeightCm * PPI;
            const gapX = state.gaps.x * PPI;
            const gapY = state.gaps.y * PPI;
            const mLeft = state.margins.left * PPI;
            const mTop = state.margins.top * PPI;
            const mBottom = state.margins.bottom * PPI;

            const headerTxt = document.getElementById('header-text').value;
            const headerSize = parseFloat(document.getElementById('header-size').value);
            const footerTxt = document.getElementById('footer-text').value;
            const footerSize = parseFloat(document.getElementById('footer-size').value);
            const headerMult = parseFloat(document.getElementById('header-zone-mult').value) || 1.5;
            const footerMult = parseFloat(document.getElementById('footer-zone-mult').value) || 1.5;

            const headerZoneH = headerTxt ? (headerSize * headerMult) : 0;
            const footerZoneH = footerTxt ? (footerSize * footerMult) : 0;

            const contentAreaTop = mTop + headerZoneH;
            const contentAreaBottom = canvas.height - mBottom - footerZoneH;
            const contentAvailableHeight = contentAreaBottom - contentAreaTop;

            const collageW = (slotW * 2) + gapX;
            const collageH = (state.word.length * slotH) + ((state.word.length - 1) * gapY);
            const startX = (canvas.width - collageW) / 2;

            const align = document.getElementById('collage-align').value;
            let startY = contentAreaTop;
            
            if (align === 'center') {
                startY = contentAreaTop + (contentAvailableHeight - collageH) / 2;
            } else if (align === 'bottom') {
                startY = contentAreaBottom - collageH;
            }

            state.slots.forEach(slot => {
                const sx = startX + (slot.col * (slotW + gapX));
                const sy = startY + (slot.row * (slotH + gapY));
                
                ctx.fillStyle = slot.bgColor;
                ctx.fillRect(sx, sy, slotW, slotH);

                if (slot.img) ctx.drawImage(slot.img, sx, sy, slotW, slotH);
            });

            if (headerTxt) {
                setupFontBasic(ctx, 'header');
                const align = document.getElementById('header-align').value;
                const zoneTop = mTop;
                const zoneBottom = mTop + headerZoneH;
                const zoneHeight = headerZoneH;
                
                ctx.textBaseline = "alphabetic";
                const metrics = ctx.measureText(headerTxt);
                const textHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
                
                let textY = 0;
                if (align === 'top') textY = zoneTop + metrics.actualBoundingBoxAscent + 5;
                else if (align === 'bottom') textY = zoneBottom - metrics.actualBoundingBoxDescent - 5;
                else textY = zoneTop + (zoneHeight / 2) + (textHeight / 2) - metrics.actualBoundingBoxDescent;
                
                ctx.fillText(headerTxt, canvas.width / 2, textY);
            }

            if (footerTxt) {
                setupFontBasic(ctx, 'footer');
                const align = document.getElementById('footer-align').value;
                const zoneBottom = canvas.height - mBottom;
                const zoneTop = zoneBottom - footerZoneH;
                const zoneHeight = footerZoneH;

                ctx.textBaseline = "alphabetic";
                const metrics = ctx.measureText(footerTxt);
                const textHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
                
                let textY = 0;
                if (align === 'top') textY = zoneTop + metrics.actualBoundingBoxAscent + 5;
                else if (align === 'bottom') textY = zoneBottom - metrics.actualBoundingBoxDescent - 5;
                else textY = zoneTop + (zoneHeight / 2) + (textHeight / 2) - metrics.actualBoundingBoxDescent;

                ctx.fillText(footerTxt, canvas.width / 2, textY);
            }

            const sizePercent = parseInt(document.getElementById('word-size-percent').value) / 100;
            const fontFamily = document.getElementById('word-font-family').value;
            let wStyle = "";
            if (document.getElementById('word-bold').checked) wStyle += "bold ";
            if (document.getElementById('word-italic').checked) wStyle += "italic ";
            const fontStrBase = `${wStyle} {size}px ${fontFamily}`;

            ctx.fillStyle = document.getElementById('word-color').value;
            ctx.textBaseline = "top";

            for (let i = 0; i < state.word.length; i++) {
                const char = state.word[i];
                
                const testSize = 200;
                const v = getVisualMetrics(char, fontStrBase.replace('{size}', testSize), testSize);
                
                const targetPixelHeight = slotH * sizePercent;
                const scale = targetPixelHeight / v.height;
                const finalFontSize = (testSize * scale) + 10;

                const fv = getVisualMetrics(char, fontStrBase.replace('{size}', finalFontSize), finalFontSize);

                const rowTop = startY + (i * (slotH + gapY));
                const drawY = (rowTop + (slotH / 2)) - (fv.top + (fv.height / 2));
                const rowCenterX = startX + slotW + (gapX / 2);

                ctx.font = fontStrBase.replace('{size}', finalFontSize);
                ctx.textAlign = "center";
                ctx.shadowColor = "rgba(0,0,0,0)";
                ctx.shadowBlur = 0;
                
                ctx.fillText(char, rowCenterX, drawY);
                ctx.shadowBlur = 0;
            }
        }

        function setupFontBasic(ctx, type) {
            let prefix = type;
            let size = document.getElementById(prefix + '-size').value;
            let family = document.getElementById(prefix + '-font').value;
            let color = document.getElementById(prefix + '-color').value;
            let isBold = document.getElementById(prefix + '-bold').checked;
            let isItalic = document.getElementById(prefix + '-italic').checked;
            let style = "";
            if (isBold) style += "bold ";
            if (isItalic) style += "italic ";
            ctx.font = `${style} ${size}px ${family}`;
            ctx.fillStyle = color;
            ctx.textAlign = "center";
        }

        function setupEvents() {
            canvas.addEventListener('mousedown', (e) => {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const mouseX = (e.clientX - rect.left) * scaleX;
                const mouseY = (e.clientY - rect.top) * scaleY;

                const slotW = state.slotWidthCm * PPI;
                const slotH = state.slotHeightCm * PPI;
                const gapX = state.gaps.x * PPI;
                const gapY = state.gaps.y * PPI;
                const mTop = state.margins.top * PPI;
                const mBottom = state.margins.bottom * PPI;
                
                const headerTxt = document.getElementById('header-text').value;
                const headerSize = parseFloat(document.getElementById('header-size').value);
                const footerTxt = document.getElementById('footer-text').value;
                const footerSize = parseFloat(document.getElementById('footer-size').value);
                const headerMult = parseFloat(document.getElementById('header-zone-mult').value) || 1.5;
                const footerMult = parseFloat(document.getElementById('footer-zone-mult').value) || 1.5;

                const headerZoneH = headerTxt ? (headerSize * headerMult) : 0;
                const footerZoneH = footerTxt ? (footerSize * footerMult) : 0;

                const collageAreaTop = mTop + headerZoneH;
                const collageAreaBottom = canvas.height - mBottom - footerZoneH;
                const collageAvailableH = collageAreaBottom - collageAreaTop;

                const collageW = (slotW * 2) + gapX;
                const collageH = (state.word.length * slotH) + ((state.word.length - 1) * gapY);
                const startX = (canvas.width - collageW) / 2;

                const align = document.getElementById('collage-align').value;
                let startY = collageAreaTop;
                if (align === 'center') startY = collageAreaTop + (collageAvailableH - collageH) / 2;
                else if (align === 'bottom') startY = collageAreaBottom - collageH;

                const clickedSlot = state.slots.find(slot => {
                    const sx = startX + (slot.col * (slotW + gapX));
                    const sy = startY + (slot.row * (slotH + gapY));
                    return mouseX >= sx && mouseX <= sx + slotW &&
                           mouseY >= sy && mouseY <= sy + slotH;
                });

                if (clickedSlot) {
                    state.activeSlotIndex = clickedSlot.id;
                    if (clickedSlot.originalUrl) openCropper(clickedSlot.originalUrl);
                    else uploader.click();
                }
            });

            uploader.addEventListener('change', (e) => {
                if (e.target.files && e.target.files[0]) {
                    const reader = new FileReader();
                    reader.onload = (evt) => {
                        state.slots[state.activeSlotIndex].originalUrl = evt.target.result;
                        openCropper(evt.target.result);
                    };
                    reader.readAsDataURL(e.target.files[0]);
                }
                uploader.value = '';
            });

            document.getElementById('crop-save-btn').addEventListener('click', () => {
                if (cropper) {
                    const croppedCanvas = cropper.getCroppedCanvas({
                        width: state.slotWidthCm * PPI * 3,
                        height: state.slotHeightCm * PPI * 3
                    });
                    const slot = state.slots[state.activeSlotIndex];
                    const newImg = new Image();
                    newImg.onload = () => {
                        slot.img = newImg;
                        draw();
                    };
                    newImg.src = croppedCanvas.toDataURL('image/jpeg', 0.95);
                    cropperModal.hide();
                }
            });
        }

        function openCropper(url) {
            document.getElementById('cropper-image').src = url;
            cropperModal.show();
            setTimeout(() => initCropper(), 200);
        }

        function initCropper() {
            const image = document.getElementById('cropper-image');
            if (cropper) { 
                cropper.destroy(); 
                if(svgOverlayElement) svgOverlayElement.remove(); 
            }
            
            const ar = state.slotWidthCm / state.slotHeightCm;
            cropper = new Cropper(image, {
                aspectRatio: ar,
                viewMode: 1,
                dragMode: 'move',
                autoCropArea: 1,
                ready: () => createSvgOverlay(),
                // crop: () => updateSvgOverlayPosition()

                crop: () => {
                    const slot = state.slots[state.activeSlotIndex];
                    const letter = state.word[slot.row];
                    var keres = "ÁÉÍÓÖŐÚÜŰáéíóöőúüű";
                    let result = keres.includes(letter);
                    const sizePercent = parseInt(document.getElementById('word-size-percent').value);

                    console.log("result",result);
                    if (result === true && sizePercent == 100) { updateSvgOverlayPosition_ekezet(); }
                    else if (result === false && sizePercent == 100) { updateSvgOverlayPosition(); }
                    else if (result === true && sizePercent != 100) { updateSvgOverlayPosition_nemszaz_ekezet(); }
                    else if (result === false && sizePercent != 100) { updateSvgOverlayPosition_nemszaz(); }
                }
            });
        }

        function createSvgOverlay() {
            const slot = state.slots[state.activeSlotIndex];
            const letter = state.word[slot.row];
            const isLeftColumn = (slot.col === 0);
            const family = document.getElementById('word-font-family').value;
            const isBold = document.getElementById('word-bold').checked;
            const isItalic = document.getElementById('word-italic').checked;
            const colorHex = document.getElementById('word-color').value;
            const fillColor = hexToRgba(colorHex, 0.65);
            const textX = isLeftColumn ? "100%" : "0%";

            svgOverlayElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svgOverlayElement.setAttribute("class", "svg-overlay");
            
            svgOverlayElement.innerHTML = `
                <text x="${textX}" y="0" 
                      text-anchor="middle"
                      fill="${fillColor}" 
                      stroke="rgba(0,0,0,0.5)" 
                      stroke-width="0.5"
                      style="font-family: ${family}; font-weight: ${isBold?'bold':'normal'}; font-style: ${isItalic?'italic':'normal'};">
                    ${letter}
                </text>
            `;
            document.querySelector('.cropper-container').appendChild(svgOverlayElement);
            updateSvgOverlayPosition();
        }

        function updateSvgOverlayPosition() {
            if (!cropper || !svgOverlayElement) return;
            
            const cropBox = cropper.getCropBoxData();
            svgOverlayElement.style.left = cropBox.left + "px";
            svgOverlayElement.style.top = cropBox.top + "px";
            svgOverlayElement.style.width = cropBox.width + "px";
            svgOverlayElement.style.height = cropBox.height + "px";
            svgOverlayElement.setAttribute("viewBox", `0 0 ${cropBox.width} ${cropBox.height}`);

            const slot = state.slots[state.activeSlotIndex];
            const char = state.word[slot.row];
            const sizePercent = parseInt(document.getElementById('word-size-percent').value) / 100;
            const family = document.getElementById('word-font-family').value;
            const isBold = document.getElementById('word-bold').checked;
            const isItalic = document.getElementById('word-italic').checked;
            
            let wStyle = "";
            if (isBold) wStyle += "bold ";
            if (isItalic) wStyle += "italic ";
            const fontStrBase = `${wStyle} {size}px ${family}`;

            const testSize = 200;
            const v = getVisualMetrics(char, fontStrBase.replace('{size}', testSize), testSize);
            const targetHeight = cropBox.height * sizePercent;
            const scaleRatio = targetHeight / v.height;
            const requiredFontSize = testSize * scaleRatio;
            
            const finalVisualTop = v.top * scaleRatio;
            const topMargin = (cropBox.height - targetHeight) / 2;
            const drawY = topMargin;

            const textEl = svgOverlayElement.querySelector('text');
            textEl.setAttribute('style', 
                `font-family: ${family}; 
                 font-weight: ${wStyle.includes('bold')?'bold':'normal'}; 
                 font-style: ${wStyle.includes('italic')?'italic':'normal'}; 
                 font-size: ${requiredFontSize}px;`);
            
            textEl.setAttribute('y', drawY);
            textEl.setAttribute('text-anchor', 'middle');
            textEl.setAttribute('dominant-baseline', 'hanging');
        }

        function updateSvgOverlayPosition_ekezet() {
                    console.log("updateSvgOverlayPosition_ekezet");
            if (!cropper || !svgOverlayElement) return;
            
            const cropBox = cropper.getCropBoxData();
            
            svgOverlayElement.style.left = cropBox.left + "px";
            svgOverlayElement.style.top = cropBox.top + "px";
            svgOverlayElement.style.width = cropBox.width + "px";
            svgOverlayElement.style.height = cropBox.height + "px";
            svgOverlayElement.setAttribute("viewBox", `0 0 ${cropBox.width} ${cropBox.height}`);

            const slot = state.slots[state.activeSlotIndex];
            const char = state.word[slot.row];
            const isMobile = window.innerWidth < 992;
            const family = isMobile ? 
                document.getElementById('mobile-word-font-family').value : 
                document.getElementById('word-font-family').value;
            const isBold = isMobile ? 
                document.getElementById('mobile-word-bold').checked : 
                document.getElementById('word-bold').checked;
            const isItalic = isMobile ? 
                document.getElementById('mobile-word-italic').checked : 
                document.getElementById('word-italic').checked;
            
            let wStyle = "";
            if (isBold) wStyle += "bold ";
            if (isItalic) wStyle += "italic ";
            const fontStrBase = `${wStyle} {size}px ${family}`;

            const testSize = 200; 
            const v = getVisualMetrics(char, fontStrBase.replace('{size}', testSize), testSize);
            
            const sizePercent = parseInt(isMobile ? 
                document.getElementById('mobile-word-size-percent').value : 
                document.getElementById('word-size-percent').value) / 100;
            
            const targetPixelHeight = cropBox.height * sizePercent;
            const scaleRatio = targetPixelHeight / v.height;
            const requiredFontSize = testSize * scaleRatio;
            
            const calibrationOffset = 2;
            const topMargin = (cropBox.height - targetPixelHeight) / 2;
            const drawY = topMargin  + calibrationOffset;

            const textEl = svgOverlayElement.querySelector('text');
            
            textEl.setAttribute('style', 
                `font-family: ${family}; 
                 font-weight: ${wStyle.includes('bold')?'bold':'normal'}; 
                 font-style: ${wStyle.includes('italic')?'italic':'normal'}; 
                 font-size: ${requiredFontSize}px;`);
            
            textEl.setAttribute('y', drawY);
            textEl.setAttribute('text-anchor', 'middle');
            textEl.setAttribute('dominant-baseline', 'text-before-edge');
        }

        function updateSvgOverlayPosition_nemszaz_ekezet() {
            if (!cropper || !svgOverlayElement) return;
            
            const cropBox = cropper.getCropBoxData();
            
            svgOverlayElement.style.left = cropBox.left + "px";
            svgOverlayElement.style.top = cropBox.top + "px";
            svgOverlayElement.style.width = cropBox.width + "px";
            svgOverlayElement.style.height = cropBox.height + "px";
            svgOverlayElement.setAttribute("viewBox", `0 0 ${cropBox.width} ${cropBox.height}`);

            const slot = state.slots[state.activeSlotIndex];
            const char = state.word[slot.row];
            
            const isMobile = window.innerWidth < 992;
            const sizePercent = parseInt(isMobile ? 
                document.getElementById('mobile-word-size-percent').value : 
                document.getElementById('word-size-percent').value) / 100;
            
            const family = isMobile ? 
                document.getElementById('mobile-word-font-family').value : 
                document.getElementById('word-font-family').value;
            const isBold = isMobile ? 
                document.getElementById('mobile-word-bold').checked : 
                document.getElementById('word-bold').checked;
            const isItalic = isMobile ? 
                document.getElementById('mobile-word-italic').checked : 
                document.getElementById('word-italic').checked;
            
            let wStyle = "";
            if (isBold) wStyle += "bold ";
            if (isItalic) wStyle += "italic ";
            const fontStrBase = `${wStyle} {size}px ${family}`;

            const testSize = 200;
            const v = getVisualMetrics(char, fontStrBase.replace('{size}', testSize), testSize);
            
            const targetHeight = cropBox.height * sizePercent;
            const scaleRatio = targetHeight / v.height;
            const requiredFontSize = testSize * scaleRatio;
            
            const calibrationOffset = 0;
            const finalVisualTop = v.top * scaleRatio;
            const topMargin = (cropBox.height - targetHeight) / 2;
            const drawY = topMargin  + calibrationOffset-2;

            const textEl = svgOverlayElement.querySelector('text');
            
            textEl.setAttribute('style', 
                `font-family: ${family}; 
                 font-weight: ${wStyle.includes('bold')?'bold':'normal'}; 
                 font-style: ${wStyle.includes('italic')?'italic':'normal'}; 
                 font-size: ${requiredFontSize}px;`);
            
            textEl.setAttribute('y', drawY);
            textEl.setAttribute('text-anchor', 'middle');
            textEl.setAttribute('dominant-baseline', 'hanging');
        }

        function updateSvgOverlayPosition_nemszaz() {
            if (!cropper || !svgOverlayElement) return;
            
            const cropBox = cropper.getCropBoxData();
            
            svgOverlayElement.style.left = cropBox.left + "px";
            svgOverlayElement.style.top = cropBox.top + "px";
            svgOverlayElement.style.width = cropBox.width + "px";
            svgOverlayElement.style.height = cropBox.height + "px";
            svgOverlayElement.setAttribute("viewBox", `0 0 ${cropBox.width} ${cropBox.height}`);

            const slot = state.slots[state.activeSlotIndex];
            const char = state.word[slot.row];
            
            const isMobile = window.innerWidth < 992;
            const sizePercent = parseInt(isMobile ? 
                document.getElementById('mobile-word-size-percent').value : 
                document.getElementById('word-size-percent').value) / 100;
            
            const family = isMobile ? 
                document.getElementById('mobile-word-font-family').value : 
                document.getElementById('word-font-family').value;
            const isBold = isMobile ? 
                document.getElementById('mobile-word-bold').checked : 
                document.getElementById('word-bold').checked;
            const isItalic = isMobile ? 
                document.getElementById('mobile-word-italic').checked : 
                document.getElementById('word-italic').checked;
            
            let wStyle = "";
            if (isBold) wStyle += "bold ";
            if (isItalic) wStyle += "italic ";
            const fontStrBase = `${wStyle} {size}px ${family}`;

            const testSize = 200;
            const v = getVisualMetrics(char, fontStrBase.replace('{size}', testSize), testSize);
            
            const targetHeight = cropBox.height * sizePercent;
            const scaleRatio = targetHeight / v.height;
            const requiredFontSize = testSize * scaleRatio;
            
            const calibrationOffset = 0;
            const finalVisualTop = v.top * scaleRatio;
            const topMargin = (cropBox.height - targetHeight) / 2;
            const drawY = topMargin  + calibrationOffset;

            const textEl = svgOverlayElement.querySelector('text');
            
            textEl.setAttribute('style', 
                `font-family: ${family}; 
                 font-weight: ${wStyle.includes('bold')?'bold':'normal'}; 
                 font-style: ${wStyle.includes('italic')?'italic':'normal'}; 
                 font-size: ${requiredFontSize}px;`);
            
            textEl.setAttribute('y', drawY);
            textEl.setAttribute('text-anchor', 'middle');
            textEl.setAttribute('dominant-baseline', 'hanging');
        }


        function downloadCanvas() {
            const link = document.createElement('a');
            link.download = `kollazs-${state.word}.jpg`;
            link.href = canvas.toDataURL('image/jpeg', 0.95);
            link.click();
        }

        window.onload = init;
    </script>
</body>
</html>
            